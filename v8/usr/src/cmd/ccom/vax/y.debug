#ifdef YYDEBUG
char *yytoknames[] = {
0,0,"NAME",
"STRING",
"ICON",
"FCON",
"+",
0,"-",
0,0,"*",
0,0,"&",
0,0,"|",
0,"^",
0,"?",
":",
"&&",
"||",
"ASGOP",
"RELOP",
"EQUOP",
"DIVOP",
"SHIFTOP",
"INCROP",
"UNARYOP",
"STROP",
"TYPE",
"CLASS",
"STRUCT",
"RETURN",
"GOTO",
"IF",
"ELSE",
"SWITCH",
"BREAK",
"CONTINUE",
"WHILE",
"DO",
"FOR",
"DEFAULT",
"CASE",
"SIZEOF",
"ENUM",
"(",
")",
"{",
"}",
"[",
"]",
",",
";",
"=",
"ASM",
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,};
char *yystates[] = {
"", /*0*/
"expected an external definition\n", /*1*/
"", /*2*/
"", /*3*/
"", /*4*/
"semicolon required\n", /*5*/
"expected one of NAME * ( ;\n", /*6*/
"", /*7*/
"", /*8*/
"", /*9*/
"", /*10*/
"", /*11*/
"", /*12*/
"", /*13*/
"{ expected in struct decl\n", /*14*/
"", /*15*/
"{ expected in enum decl\n", /*16*/
"", /*17*/
"", /*18*/
"", /*19*/
"expected , or ;\n", /*20*/
"", /*21*/
"", /*22*/
"expected one of NAME * (\n", /*23*/
"expected one of NAME * (\n", /*24*/
"", /*25*/
"", /*26*/
"expected = in intializer\n", /*27*/
"", /*28*/
"", /*29*/
"", /*30*/
"", /*31*/
"", /*32*/
"expected TYPE STRUCT or ENUM\n", /*33*/
"", /*34*/
"an enum must be a NAME\n", /*35*/
"", /*36*/
"", /*37*/
"", /*38*/
"", /*39*/
") required\n", /*40*/
"", /*41*/
"", /*42*/
"", /*43*/
"expected ( ) or [\n", /*44*/
"expected ( ) or [\n", /*45*/
"expected a NAME in list\n", /*46*/
") required\n", /*47*/
") required\n", /*48*/
"", /*49*/
"{ or expression required in intialization\n", /*50*/
"", /*51*/
"", /*52*/
"", /*53*/
"", /*54*/
"", /*55*/
"type_declaration expected one of NAME * : ( } ;\n", /*56*/
"", /*57*/
"", /*58*/
"", /*59*/
"expected one of NAME * (\n", /*60*/
"", /*61*/
"function_body needs a declaration or {\n", /*62*/
"", /*63*/
"", /*64*/
"] required\n", /*65*/
"need constant expression\n", /*66*/
"", /*67*/
"", /*68*/
"expect ) or ,\n", /*69*/
"", /*70*/
"", /*71*/
"", /*72*/
"", /*73*/
"", /*74*/
"] needed\n", /*75*/
"", /*76*/
"expecte expr or { in initializer\n", /*77*/
"", /*78*/
"term :  *.term \n", /*79*/
"term :  &.term \n", /*80*/
"term :  -.term \n", /*81*/
"term :  UNARYOP.term \n", /*82*/
"term :  INCROP.term \n", /*83*/
"term :  SIZEOF.term \nterm :  SIZEOF.( cast_type ) \n", /*84*/
"term :  (.cast_type ) term \nterm :  (.e ) \n", /*85*/
"expected ) or expression\n", /*86*/
"", /*87*/
"", /*88*/
"", /*89*/
"", /*90*/
"} needed\n", /*91*/
"", /*92*/
"", /*93*/
"", /*94*/
"", /*95*/
"", /*96*/
"", /*97*/
"expected one of NAME * (\n", /*98*/
"", /*99*/
"expected one of NAME * (\n", /*100*/
"enum_dcl must end with }\n", /*101*/
"", /*102*/
"", /*103*/
"", /*104*/
"", /*105*/
"", /*106*/
"expected one of NAME * : ( ;\n", /*107*/
"", /*108*/
"", /*109*/
"", /*110*/
"", /*111*/
"", /*112*/
"name_list :  name_list ,.NAME \n", /*113*/
"", /*114*/
"e :  e RELOP.e \n", /*115*/
"e :  e ,.e \n", /*116*/
"e :  e DIVOP.e \ne :  e DIVOP.ASSIGN e \n", /*117*/
"e :  e +.e \ne :  e PLUS.ASSIGN e \n", /*118*/
"e :  e -.e \ne :  e MINUS.ASSIGN e \n", /*119*/
"e :  e SHIFTOP.e \ne :  e SHIFTOP.ASSIGN e \n", /*120*/
"e :  e *.e \ne :  e MUL.ASSIGN e \n", /*121*/
"e :  e EQUOP.e \n", /*122*/
"e :  e &.e \ne :  e AND.ASSIGN e \n", /*123*/
"e :  e |.e \ne :  e OR.ASSIGN e \n", /*124*/
"e :  e ^.e \ne :  e ER.ASSIGN e \n", /*125*/
"e :  e &&.e \n", /*126*/
"e :  e ||.e \n", /*127*/
"e :  e ?.e : e \n", /*128*/
"e :  e ASOP.e \n", /*129*/
"e :  e =.e \n", /*130*/
"", /*131*/
"", /*132*/
"", /*133*/
"initializer needs expr or {\n", /*134*/
"", /*135*/
"", /*136*/
"term :  term [.e ] \nterm :  term [.e : e ] \n", /*137*/
"term :  term STROP.NAME \n", /*138*/
"", /*139*/
"", /*140*/
"", /*141*/
"", /*142*/
"", /*143*/
"", /*144*/
"", /*145*/
"term :  (.cast_type ) term \nterm :  SIZEOF (.cast_type ) \nterm :  (.e ) \n", /*146*/
"term :  ( cast_type.) term \n", /*147*/
"expected operator or ) after expression\n", /*148*/
"", /*149*/
"", /*150*/
"expected , or )\n", /*151*/
"", /*152*/
"", /*153*/
"", /*154*/
"", /*155*/
"", /*156*/
"", /*157*/
"", /*158*/
"", /*159*/
"", /*160*/
"", /*161*/
"expected , or ;\n", /*162*/
"", /*163*/
"", /*164*/
"", /*165*/
"", /*166*/
"", /*167*/
"", /*168*/
"e :  e DIVOP =.e \n", /*169*/
"", /*170*/
"e :  e + =.e \n", /*171*/
"", /*172*/
"e :  e - =.e \n", /*173*/
"", /*174*/
"e :  e SHIFTOP =.e \n", /*175*/
"", /*176*/
"e :  e * =.e \n", /*177*/
"", /*178*/
"", /*179*/
"e :  e & =.e \n", /*180*/
"", /*181*/
"e :  e | =.e \n", /*182*/
"", /*183*/
"e :  e ^ =.e \n", /*184*/
"", /*185*/
"", /*186*/
"operator expected after expression\n", /*187*/
"", /*188*/
"", /*189*/
"init list must end with }\n", /*190*/
"", /*191*/
"", /*192*/
"operator expected after expression\n", /*193*/
"", /*194*/
") required\n", /*195*/
"term :  ( cast_type ).term \n", /*196*/
"", /*197*/
"", /*198*/
"", /*199*/
"", /*200*/
"elist :  elist ,.e \n", /*201*/
"", /*202*/
"expected one of NAME * : (\n", /*203*/
"", /*204*/
"", /*205*/
"expected one of NAME * ( ;\n", /*206*/
"stmt_list :  stmt_list.statement \ncompoundstmt :  begin dcl_stat_list stmt_list.} \n", /*207*/
"", /*208*/
"", /*209*/
"", /*210*/
"", /*211*/
"", /*212*/
"", /*213*/
"", /*214*/
"", /*215*/
"e :  e ? e :.e \n", /*216*/
"", /*217*/
"", /*218*/
"} expected\n", /*219*/
"", /*220*/
"term :  term [ e :.e ] \n", /*221*/
"", /*222*/
"", /*223*/
"", /*224*/
"", /*225*/
"expected ) or [\n", /*226*/
"", /*227*/
"", /*228*/
"", /*229*/
"", /*230*/
"expected one of , or ;\n", /*231*/
"", /*232*/
"", /*233*/
"; or operator expected after expression\n", /*234*/
"; reuired\n", /*235*/
"", /*236*/
"statement :  ifprefix.statement \nifelprefix :  ifprefix.statement ELSE \n", /*237*/
"statement :  ifelprefix.statement \n", /*238*/
"", /*239*/
"statement :  doprefix.statement WHILE ( e ) ; \n", /*240*/
"statement :  FOR.( e ; e ; e ) statement \n", /*241*/
"statement :  switchpart.statement \n", /*242*/
"statement :  BREAK.; \n", /*243*/
"statement :  CONTINUE.; \n", /*244*/
"statement :  RETURN.; \nstatement :  RETURN.e ; \n", /*245*/
"statement :  GOTO.NAME ; \n", /*246*/
"", /*247*/
"statement :  error.; \nstatement :  error.} \n", /*248*/
"statement :  label.statement \n", /*249*/
"ifprefix :  IF.( e ) \n", /*250*/
"", /*251*/
"switchpart :  SWITCH.( e ) \n", /*252*/
"", /*253*/
"label :  CASE.e : \n", /*254*/
"label :  DEFAULT.: \n", /*255*/
"", /*256*/
"", /*257*/
"expected an operator or ]\n", /*258*/
"", /*259*/
"null_decl :  null_decl [ con_e.] \n", /*260*/
"", /*261*/
"", /*262*/
"", /*263*/
"", /*264*/
"", /*265*/
"", /*266*/
"statement :  WHILE .( e ) statement \n", /*267*/
"statement :  doprefix statement.WHILE ( e ) ; \n", /*268*/
"", /*269*/
"", /*270*/
"", /*271*/
"", /*272*/
"", /*273*/
"expected a ; or an operator\n", /*274*/
"statement :  GOTO NAME.; \n", /*275*/
"", /*276*/
"", /*277*/
"", /*278*/
"ifprefix :  IF (.e ) \n", /*279*/
"switchpart :  SWITCH (.e ) \n", /*280*/
"", /*281*/
"expected a : or an operator\n", /*282*/
"", /*283*/
"", /*284*/
"", /*285*/
"null_decl :  ( null_decl ) (.) \n", /*286*/
"", /*287*/
"statement :  WHILE (.e ) statement \n", /*288*/
"statement :  doprefix statement WHILE.( e ) ; \n", /*289*/
"statement :  FOR ( e.; e ; e ) statement \n", /*290*/
"", /*291*/
"", /*292*/
"", /*293*/
"expected ) or operator\n", /*294*/
"expected ) or operator\n", /*295*/
"", /*296*/
"", /*297*/
"expected ) or operator\n", /*298*/
"statement :  doprefix statement WHILE (.e ) ; \n", /*299*/
"", /*300*/
"", /*301*/
"", /*302*/
"", /*303*/
"expected ) or operator\n", /*304*/
"", /*305*/
"statement :  WHILE ( e ).statement \n", /*306*/
"statement :  doprefix statement WHILE ( e ).; \n", /*307*/
"statement :  FOR ( e ; e.; e ) statement \n", /*308*/
"", /*309*/
"", /*310*/
"", /*311*/
"", /*312*/
"statement :  FOR ( e ; e ; e.) statement \n", /*313*/
"statement :  FOR ( e ; e ; e ).statement \n", /*314*/
"", /*315*/
};
#endif
