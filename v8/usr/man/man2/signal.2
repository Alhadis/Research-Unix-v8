.TH SIGNAL 2 
.SH NAME
signal \- catch or ignore signals
.SH SYNOPSIS
.nf
.B #include <signal.h>
.PP
.B int (*signal(sig, func))()
.B int (*func)();
.fi
.SH DESCRIPTION
A signal
is generated by some abnormal event,
initiated either by user at a terminal (quit, interrupt),
by a program error (bus error, etc.),
or by request of another program (kill).
Normally all signals
cause termination of the receiving process,
but a
.I signal
call allows them either to be ignored
or to cause an interrupt to a specified location.
Here is the list of signals with names as in
the include file.
.LP
.nf
.ta \w'SIGMMMM 'u +\w'15*  'u
SIGHUP	1	hangup
SIGINT	2	interrupt
SIGQUIT	3*	quit
SIGILL	4*	illegal instruction (not reset when caught)
SIGTRAP	5*	trace trap (not reset when caught)
SIGIOT	6*	IOT instruction
SIGEMT	7*	EMT instruction
SIGFPE	8*	floating point exception
SIGKILL	9	kill (cannot be caught or ignored)
SIGBUS	10*	bus error
SIGSEGV	11*	segmentation violation
SIGSYS	12*	bad argument to system call
SIGPIPE	13	write on a pipe with no one to read it
SIGALRM	14	alarm clock
SIGTERM	15	software termination signal
	16	unassigned
SIGSTOP	17+	stop (cannot be caught, held or ignored)
SIGCONT	19#	continue a stopped process
SIGCHLD	20#	child has stopped or exited
.sp
*	causes core image if not caught or ignored
+	suspends process until SIGCONT or PIOCRUN, see \fIproc\fR(4)
#	ignored if not caught
.fi
.PP
Signals 1 through NSIG, defined in the include file,
exist.
Those not listed above have
no conventional meaning in this system.
(Berkeley systems use 1-15 and 17-25).
.PP
If
.I func
is SIG_DFL, the default action
for signal
.I sig
is reinstated; this default is termination,
sometimes with a core image.
If
.I func
is SIG_IGN the signal is ignored.
Otherwise
when the signal occurs
.I func
will be called with the
signal number as argument.
A return from the function will
continue the process at the point it was interrupted.
.PP
Except as indicated,
a signal is reset to SIG_DFL after being caught.
Thus if it is desired to
catch every such signal,
the catching routine must
issue another
.I signal
call.
.PP
When a caught signal occurs
during certain system calls, the call terminates prematurely.
In particular this can occur during
.IR read
or 
.IR write (2)
on a slow device (like a typewriter; but not a file);
and during
.I pause
and
.IR wait (2).
When such a signal occurs, the saved user status
is arranged so that when return from the
signal-catching takes place, it will appear that the
system call returned an error status.
The user's program may then, if it wishes, re-execute the call.
.PP
The value of
.I signal
is the previous (or initial)
value of
.I func
for the particular signal.
.PP
After a
.IR  fork (2)
the child inherits
all signals.
.IR  Exec (2)
resets all
caught signals to default action.
.SH "SEE ALSO"
kill(1),
kill(2),
setjmp(3),
proc(4)
.SH DIAGNOSTICS
The value (int)\-1 is returned if the
given signal is out of range.
.SH BUGS
Unadvertised and unsupported 
.I func
arguments can radically and permanently change the
behavior of signals.
.br
Trap syndromes should be distinguishable by extra arguments
to the signal handler.
.br
If a repeated signal arrives before the last one can be
reset, there is no chance to catch it.
.br
The type specification of the routine and its
.I func
argument are problematical.
At the very least the type should be `void (*)()'.
