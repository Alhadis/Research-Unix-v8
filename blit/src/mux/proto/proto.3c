.TH PROTO 3C
.SH NAME
proto, pinit, psend, precv \- multiplexed channels protocol
.SH SYNOPSIS
.B "#include <proto.h>"
.PP
.B "int pinit(channels)"
.br
.B "int channels;"
.PP
.B "void precv(ptr, size)"
.br
.B "char \(**ptr;"
.br
.B "int size;"
.PP
.B "int psend(channel, ptr, size)"
.br
.B "int channel;"
.br
.B "char \(**ptr;"
.br
.B "int size;"
.PP
.B "void ptimeout(sig)"
.br
.B "int sig;"
.PP
.B "struct Pchannel pconvs[];"
.PP
.B "struct Pconfig pconfig;"
.SH DESCRIPTION
These routines implement a machine independent driver for
full duplex multiplexed multi-buffered channels
with guaranteed delivery of ordered data via an 8 bit byte data stream.
.SH CONFIGURATION
The protocol driver assumes an 8 bit byte data stream described by the field
.I xfdesc\^
in the user initialised structure
.IR pconfig .
The user must also supply the addresses of routines
with which to write packets to the data stream,
and to receive unpacked data from the stream,
and control information from the stream.
These are initialised in the fields
.IR xfuncp ", " rfuncp " and " rcfuncp .
.PP
The routine
.I \(**xfuncp\^
will be invoked with arguments as for the
.IR write (2)
system call.
The first argument will be
.IR xfdesc ,
and the next two a pointer to a packet, and its size.
.PP
The routines
.IR \(**rfuncp " and " \(**rcfuncp
are invoked with three arguments,
the first a channel number,
and the next two a pointer to data from that channel,
and its size.
If
.I \(**rfuncp\^
returns a non-zero result,
the packet will be negatively acknowledged,
causing a later re-transmission.
The routine
.I \(**rcfuncp\^
will only be called with data from a control packet.
This data is generated by placing a (non-zero) byte
in the
.IR pconfig " field " cdata
during an invocation of the
routine
.IR \(**rfuncp .
The control byte will be returned to the remote channel in the
acknowledgement packet,
there to be delivered by an invocation of
.IR \(**rcfuncp .
Caveat:
control data can be delivered asynchronously to stream data,
and its delivery is uncertain.
It is intended that control data be used primarily as an aid to flow control.
.SH PROTOCOL
The protocol uses packets with a 2 byte header containing
sequence number (modulo
.SM SEQMOD\c
),
channel number,
control flag,
and data size.
The data part of a packet may not be larger than
.SM MAXPKTDSIZE.
The trailer contains a CRC-16 code in 2 bytes.
Each channel is multi-buffered,
the number of buffers being defined by the parameter
.SM NPCBUFS.
.PP
Correctly received packets in sequence are acknowledged with a control
packet containing an
.SM ACK\c
, out of sequence packets generate a control packet containing a
.SM NAK
, which will cause the retransmission in sequence of all un-acknowledged packets.
.PP
Unacknowledged packets are retransmitted after a timeout specified
by the
.IR pconfig " field " xtimo
in the same units as the field
.I tscan
which is the period of a timeout scan.
Incomplete receive packets are discarded after a timeout
specified by the field
.IR rtimo .
These fields, if zero,
will be initialised to a default setting appropriate for a
1200 baud RS-232 data stream.
If other data stream speeds are used,
the timeout fields should be preset as follows:-
.PP
If
.I speed
is in bytes per
.I tscan
unit, then
.I xtimo
should be set to:
.br
.ce
.B "max(3,\ (NCHAN\(**NPCBUFS\(**sizeof(struct Packet)+speed-1)/speed)"
.br
and
.I rtimo
to:
.br
.ce
.B "max(2,\ (sizeof(struct rPacket)+speed-1)/speed)"
.SH INITIALISATION
.I Pinit\^
initialises the transmitter and receiver data.
Transmitter structures must be declared by the caller in an array
.B "struct Pchannel\ pconvs[NCHAN];"
and the size
.SM NCHAN
passed as first argument to
.IR pinit .
.SM NCHAN
must not be greater than
.SM MAXPCHAN.
.I Pinit
also enables
.SM SIGALRM
to call the timeout handler
.IR ptimeout .
.I Pinit
returns a non-zero result if an initialisation inconsistency is detected.
.SH USAGE
.I Precv
is called with a pointer to data read from the data stream
(e.g. via a
.IR read (2)
system call),
and its size.
It will collect a packet,
or acknowledgement,
from the incoming data, and invoke
.IR \(**rfuncp ", (or " \(**rcfuncp )
when a good packet has been identified,
calling
.I \(**xfuncp
to send acknowledgements.
.PP
.I Psend
is called with three arguments,
the first a channel number,
and the next two a pointer to data destined for that channel,
and its size.
It returns -1 if the channel is blocked and it cannot accept the data,
otherwise it returns the value returned by
.IR \(**xfuncp .
.PP
In each
.I Pchannel
structure
a field
.I freepkts
is set to the number of free packet buffers available for the channel;
there is also a spare byte,
.IR user .
.SH DEFAULTS
.PD 0
.TP \w'MAXPKTDSIZExx'u
MAXPCHAN
8  (3 bits in header)
.TP
SEQMOD
8  (3 bits in header)
.TP
NPCBUFS
2  (maximum SEQMOD/2)
.TP
MAXPKTDSIZE
32 (limited by buffering in system)
.PD
.SH STATISTICS
Optional statistics are available by recompiling the
source with the C compiler flag
.BI -D PSTATISTICS .
This declares an array
.I pstats
of type
.I "struct Pstatistics"
of size
.SM PS_NSTATS.
Additional descriptive strings are initialised by the flag
.BI -D PSTATSDESC .
A particular statistic \fBi\fR may then be obtained on standard
output by:
.br
.ce
.B
printf("%s: %ld", pstats[i].descp, (long)pstats[i].count);
.SH "SEE ALSO"
cc(1),
alarm(2),
read(2),
signal(2),
write(2).
