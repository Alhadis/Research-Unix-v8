.TH JOFF 1 Blit
.SH NAME
joff \- symbolic debugger
.SH SYNOPSIS
.B joff
[-\fBo\fIfile\fP]
.SH DESCRIPTION
.I Joff
is a source-level symbolic debugger for C programs running under
.I mpx.
Running asynchronously and
communicating by means of the keyboard and mouse in its
own layer, it provides for controlled execution of another process running under
.I mpx.
It takes advantage of the
source symbol tables generated by 
.I mcc's
\-g option.
.SH MODEL
Most commands manipulate and are interpreted with respect to three
major values:
.IP
i) \fIstate\fP: the active statement in the debugged process
.IP
ii) \fIcurrent context\fP: the active statement in one of the functions on the call stack
.IP
iii) \fIcurrent location\fP: an arbitrary address within Blit memory
.LP
If there is a state, it is displayed in a status line at the top of
.I joff's
layer; otherwise an appropriate message appears there.
If there is a current context, the last item on the button 3 menu
is ``\fIfunc_id\fP() vars'', where \fIfunc_id\fP is the function.
If the current location is non-zero, it appears as the normal command prompt. 
.SH INTERACTION
Apart from the status line (which video inverts momentarily whenever
its contents change),
.I joff's
layer scrolls conventionally.
.PP
.I Joff
usually prompts ``:'' (or ``\fIaddress\fP:'' with the current location)
when it is ready to accept a command entered from either the keyboard or
a mouse menu.
If a ``dead mouse'' icon replaces the cursor, the mouse may not be used.
This happens only when prompting for the symbol table file and
when waiting for the ``Debug'' selection from
.I mpx's
main menu.
The ``menu'' icon that replaces the cursor shows when there are menus available
on buttons 2 and/or 3.
It is always safe to raise a menu. If it is not what you want, don't select
anything and there is no harm done.
When
.I joff
is busy for a long period,
a ``coffee cup'' icon replaces the cursor.
.PP
If invoked with \-o,
.I joff
examines a program directly from its object file.
In this mode
.I joff
need not run under
.I mpx.
.SH MOUSE
Buttons 2 and 3 display command menus.
Button 3 commands treat the process only at the source language level.
Button 2 commands allow further access to the 68000 as raw memory.
Selecting nothing from a menu is always safe; it has no effect.
Selecting ``more...'' at the top or bottom of a menu, moves to another portion of
a menu which is too large to be displayed.
Some commands call for confirmation by a second button hit on a ``skull'' cursor.
.SH Button 3
.TP
.B layer
Selects a new layer for examination.
The layer is identified by picking
.B Debug
from the
.I mpx
menu and then hitting the layer with the ``bullseye'' cursor.
The layer is flashed by video invert.
There is then a prompt for an object file with \-g symbol tables.
Response is a file name, or null (carriage return) to select the default as shown,
or ``\-'' to proceed without symbols.
The default file name is taken from the
.I 68ld
command which loaded the layer.
It is therefore best to give an
.I absolute
pathname when using
.I 68ld
and
.I jx
in shell scripts and programs.
.TP
.B quit
Must be confirmed.
.TP
.B breakpts
Repeatedly offers a further menu on button 3 with the commands
.B list [\fIn\fB], clear all
and a list of functions in the program.
The value in brackets with
.B list
shows how many breakpoints are currently set.
The commands list and clear them all, respectively.
.B Clear all
must be confirmed.
Selecting a function identifier offers a terminal menu with
.ce
.B call
.ce
.B return
.ce
.B both
.ce
.B none
One of these is tagged by ``>'', indicating what breakpoints are set.
Selecting one modifies the breakpoints on the function. 
The breakpoint at function call is
.I after
the stack frame has been advanced,
but
.I before
initialization of the registers and automatics.
The breakpoint on function return is
.I after
the return value has been set, but
.I before
the stack frame is retracted.
It is safe to set and clear breakpoints
.I while the process is running.
To set breakpoints before the program starts, use the \-z option
on
.I 68ld
to leave the process halted after loading.
Breakpoints can only be set on individual C statements by means
of the keyboard (below).
.TP
.B globals
Repeatedly offers a menu with the program's globals.
Each one selected is displayed.
.TP
.B stmt step
Executes a single statement of the program.
After it is executed the status line shows the next statement to be
executed.
See the .sd keyboard command for specifying directories to search for
source files.
If the statement returns to the calling function,
the current context will not set and
\fBfunction\fP or \fBtraceback\fP must be used explicitly before
local variables are accessible.
Statement stepping can only be used after stopping on breakpoint.
It isn't available when the process is merely suspended by \fBhalt\fP.
.TP
.B go
Resumes execution of the process.
.TP
.B halt
Suspends execution of the process.
.TP
.B traceback
Lists the active function stack frames from the one that
is executing back to main().
Each line in the traceback has the form
.ce
\fIfile\fP:\fIline\fP[+\fIoffset\fP] in \fIfunction(arg, ... arg)\fP
giving the statement being executed as source file, line number
(and instruction byte offset) within a function and its arguments.
The deepest stack frame becomes the current context.
.TP
.B function
Offers a menu of functions (in traceback order) from which one may be selected
as current context.
.TP
.I func_id\fB() vars
Repeatedly offers a menu of the local variables, arguments and statics 
which are alive at the active statement in the current stack frame.
Each variable is classified as ``lcl'' (local), ``reg'' (register), ``sta''
(static) or ``arg'' (argument).
.SH Pointer Chasing
.PP
If a variable selected from the global or local menu is a structure,
a pointer to a structure or an array, it is displayed as one of
.ce 3
\fIvariable\fP .  <field>
\fIvariable\fP \-> <field>
\fIvariable\fP    <index>
.LP
respectively.
The menu on button 3 can then be used to complete the expression and
display its value.
While the expression this yields is still an aggregate,
a futher selection must be made to extend it.
Making no selection or hitting button 1 or 2 ``backs up'' out of an 
expression.
.PP
If the structure reached is a Point, Rectangle, Texture, Bitmap or Layer
a special operation point(), outline(), texture() or bitblt()
also appears in the menu to display the object graphically.
.SH Button 2
.PP
Button 2 has commands which root around in memory displaying it as bytes, words
(16 bits), long words (32 bits), structures, unions and enumerations.
Before using this, the command
.ce 1
 . \fIexpression\fP
is needed to set the current location to the value of the expression.
.PP
The model for this button is that the menu itself is a window into memory.
Selections from the menu change the location, size and format of the objects
seen the next time it is raised and can
copy useful ones into the scrolling area.
.PP 
The top three menu items are the location and
value for the current memory location (tagged by ``.'')
and its two neighbors.
Selecting one of these three writes it into the scrolling
area and makes that location the current one.
.PP
Selecting \fBbyte, word, long\fP fixes the size of objects viewed.
Selecting \fBdecimal, octal, hex, ascii\fP fixes the radix.
The ascii radix displays each byte as a C character
constant (e.g. 'a', '\\n', '\\277').
.PP
For pointer chasing, if the object size is \fBlong\fP and
the value at the current location makes sense as an address,
the location referenced and its value are shown (tagged by ``*''.)
It can be picked to become the current location.
.PP
\fBString\fP shows the zero-terminated strings starting at the current location,
and at current\-4 and current+4.
Long strings are truncated.
.PP
\fBstruct\f and \fBenum\fP present menus of the structures and enumerations
in the program.
Selecting one interprets memory as a vector of such objects.
Most structures are horribly truncated in the menu, but are displayed in full
when selected and displayed in the scrolling area.
.PP
If a there is a symbolic form for the current location it is displayed as
an item tagged by ``.''.
Selecting this gives a fuller symbolic form.
.PP
A final item may appear in this menu.
If
.I joff
is unable to display an object when given its symbolic name it saves
the address and places it in the menu.
It may be picked to become the current location.
.SH KEYBOARD
.I joff
repeatedly prompts with the address of the
current memory location and accepts one or more of the
following commands separated by semi-colons.
Constants may be unsigned decimal, octal or
hexadecimal, in C notation.
.TP
.B .la
Select a new layer to debug.
.TP
.B .q
Quit
.TP
.B \fIexpression\fP
Evaluate and print its value.
The following operators are supported:
.ce 2
+ \- * / %  \->  [ ] . = (binary)
& * \-            (unary)
Functions may also be called, but are executed by
.I joff's
process (while the user's is suspended if necessary.)
Structures may be expressed as \fIstruct_id(expr, ... expr)\fP,
e.g. Point(100,200).
Identifiers are bound to variables as they they would be in the current
context using C's scope rules.
.TP
.B .v
Print all local variables visible from the current context.
.TP
.B .t
Display a function traceback. Set the current context
to the deepest user function. 
.TP
.B .h
Halt the process.
.TP
.B .g
Go the process.
.TP
.B .bc \fIfunction_id\fP
Set a breakpoint at function call.
.TP
.B .br \fIfunction_id\fP
Set a breakpoint at function return.
.TP
.B .bs \fIfile line_no\fP
Set a breakpoint at a given line within a source file.
.TP
.B .cc \fIfunction_id\fP
Clear breakpoint at function call.
.TP
.B .cr \fIfunction_id\fP
Clear breakpoint at function return.
.TP
.B .cs \fIfile line_no\fP
Clear breakpoint at a given line within a source file.
.TP
.B .bl
List all breakpoints.
.TP
.B .ca
Clear all breakpoints.
.TP
.B .c [\fIcount\fP]
Set the new current context to the function which the present one calls.
When given, iterate the number of times specified by the constant.
.TP
.B .r [\fIcount\fP]
Set the new current context to the the function to which the present one returns.
When given, iterate the number of times specified by the constant.
.TP
.B .  \fIexpression\fP
Set the address of current memory location to the value of the expression.
.TP
.if n .B [+|-] \fI[offset\fP]
.if t .B [\(+-] [\fIoffset\fP]
Set the current location relative to itself by the given constant times
the size of the object last displayed.
The null command (a carriage return) is equivalent to +1.
.TP
.B .x
Find a symbolic name for the current memory location.
.TP
.B .b
Display the byte at the current location.
.TP
.B .w
Display the word (16 bits) at the current location.
.TP
.B .l 
Display the long word (32 bits) at the current location.
.TP
.B .i
Display the instruction at the current location.
.TP
.B \fIstructure_id\fP
The name of a defined structure
displays memory from the current location as an instance the structure.
Also unions and enumerations.
.TP
.B %\fIregister\fP
Set the current location to where the specified register
in the current context was saved and display as a long (32 bits).
\fIregister\fP is [ad][0\-7], sp, fp.
.TP
.B \(**
Set the address of the current location to the 32 bit address
at the current location.
.TP
.B .li \fIfile line_no\fP
Display the first instruction of code generated for
the statement beginning at a line number of a source file.
.TP
.B .= \fIexpression\fP
Write value of expression to the current memory location.
Operand length is that of the
previous .b, .w or .l command (or button 2 equivalent).
.TP
.B < \fIfile\fP
Read command script from a file.
.TP
.B .bi
Set breakpoint on the instruction at the current location.
.TP
.B .ci
Clear breakpoint at the current location.
.TP
.B .si [\fIcount\fP]
Single step the next instruction or number of instructions.
(At present this only works if already stopped on a breakpoint.)
.TP
.B .ss [\fIcount\fP]
Single step the next C statement or number of statements.
(At present this only works if already stopped on a breakpoint.)
.TP
.B .\fIbase\fP
Set radix for display of addresses, where \fIbase\fP is 8, 10 or 16.
.TP
.B .pwd
Print working directory.
.TP
.B .cd \fIdirectory\fP
Change directory
.TP
.B .sd \fIdirectory\fP
Add the directory to the front of the list of directories to be
searched for source files for displaying source lines during
statement stepping.
.SH "SEE ALSO"
mcc(1) sdb(1) mpx(1) 68ld(1)
.SH DIAGNOSTICS
The diagnostics produced by
.I joff
are intended to be self-explanatory.
Messages prefaced by ``68000: '' are generated and printed autonomously by
the terminal program when the state of the debugged process is not as expected.
They appear in exceptional situations where it is hard for
.I joff
to keep track of events.
Examples are: manually patching
breakpoint traps, wild stores to code or control memory, reloading of the 
debugged layer.
Once such a diagnostic is given there are no guarantees.
.SH BUGS
.I joff
is still evolving and has some rough edges.
The .= command can write anywhere in memory.
Anonymous structures, unions and enumerations are not supported.
For example:
.IP
typedef { int field } Record;
.LP
introduces an anonymous structure.
A simple remedy is to name the structure thus:
.IP
typedef Record { int field } Record;
.PP
